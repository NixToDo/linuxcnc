[[cha:oshwdrv-drivers]]

= OsHwDrv Drivers

This driver is for the OpenSourceHardWareDrive. It based on an FPGA
connected to LinuxCNC by parallel port (in EPP mode). All time critical
tasks are done by the FPGA. The PC only needs the servo thread.
The hole hardware (schematics, PCB layout), the programming code
of the FPGA and the LinuxCNC drivers are all open source. (For license 
details check the hardware documents.)

All this data is hosted at: http://www.github.com/nixtodo/oshwdrv

The overall function is to remove the limits of the software step generation.
So LinuxCNC will read all inputs at the beginnung of each servo cycle,
process the data (PID, ...) and then write back all new data to the board.
An typical installation has 16 digital inputs (opto isolated), 8 digital
outputs (open collector), 4 incemental encoder inputs (A, B and Index),
4 step puls generators with step and direction pins.
The board (PCB) has additional circuits for two 0 - 10 VDC outputs and two
analog inputs 0 - 10 VDC. And an SPI interface to connect an MPG.
Unused pins of the FPGA are connected to an extention connector.

= Overall function description

At startup of the LinuxCNC driver it reads the configuration from the FPGA.
There are different FPGA firmewares available (Open source).
The driver will config itselve and export HAL pins and parameters in accordance
with the FPGA programming.
If someone want different functionality or quantity of them, he only needs to modify the FPGA
firmeware. The LinuxCNC driver will adapt this the without any changes.
(Except for complete new functions, of course.)

Currently following functions are available:
* 'Digital inputs' -
   In groups of 8 Bits.
* 'Digital outputs' -
   In groups of 8 Bits. An disable signal may be used to switch all outputs off simustanaly.
* 'Step generators' -
   It produces the required timing of the step and direction signals.
   The timing of the step pules (Step puls width) and the time before / after an
   direction change (Setup time) are programmeble from 100ns to 25500ns.
   The step output frequency may vary from ~0.59 Hz (10 MHz / (2^24-1)) to 5 MHz.
   (Yes, useless for stepper drives, I know. May be changed.)
   It also includes an quadrature decoder to count an external encoder, or
   it is able to count the generated step signals if there is no external feedback device.
* 'Analog outputs' -
   The analog output will be generated by an PWM signal and filtered with an RC pass / Opamp.
   (Maybe replached by an DAC in the future.)
* 'Analog inputs' -
   The analog inputs are read from external analog to digital converters. (12 Bit resolution)
* 'Watchdog' -
   Resets all outputs to save values (= stops the machine) if the communication with LinuxCNC was lost.
   Reacts also on the HAL emergency stop circuit.
* 'PWM generators' -
   To generate a PWM signal with programmable frequency and puls / pause duration.
* 'Jog (Handweel encoder) inputs' -
   Decoder for low speed and low resolution quadrature encoders, used usally for manual jogging.
* 'Time weighted counter inputs' -
   A counter thats count pulses from digital inputs (or anything else) and divide it every second by 60.
   With this function you can measure the amount of pulses per time. Like flow sensors.
   The output will be scaled and the offset is added.
* 'MPGcom' -
   Extends the oshwdrv with an external MPG connected by SPI.
   
In my mind I have some more things:
* 'SPI slave interface' -
   To interface external hardware or to interface the driver board with a computer
   that does not have an parallel port (e.g. Raspberry Pi).
* 'UART / RS485 / Modbus interface' -
   To interface external hardware.

Installing:
----
loadrt hal_oshwdrv port_addr=<addr1>[,<addr2>[,<addr3>]] [epp_dir=<1 | 0>]
----

The 'port_addr' parameter tells the driver what parallel port(s) to 
check. By default, '<addr1>' is 0x0378, and '<addr2>' and following 
are not used. The driver searches at these addresses for any board(s).
It then exports HAL pins for whatever it finds. During loading (or attempted loading)
the driver prints some useful debugging messages to the kernel log, which can be viewed with 'dmesg'.
Up to 3 parport busses may be used, each bus with an devices on it.

== Command Line Options

There is an option that can be specified on the loadrt command line.

It was recently discovered that some parallel port chips would not work with the driver.
Especially, the Oxford OXPCIe952 chip on the SIIG PCIe parallel port cards had this trouble.
The driver in all LinuxCNC versions starting from 2.7.8 have been corrected for this problem by default.
However, this possibly could cause problems with really old EPP parallel port hardware,
so there is a command line option to go back to the previous behavior.
The new behavior is set by default, or by adding the parameter epp_dir=0 on the command line.
To get the old behavior, add epp_dir=1 to the command line. It is possible to give a list,
like epp_dir=1,0,1 to set different settings for each of up to 3 parallel ports.

== Pins

In the following pins, parameters, and functions, <port> is the parallel
port ID. According to the naming conventions the first port should always
have an ID of zero. 
The driver enumerates the boards and exports the appropriate HAL pins.
For instance, the encoders will be enumerated from zero up, in the
same order as the FPGA firmware on the board it specify it.

* '(bit output) oshwdrv.<port>.din.<channel>.in' -
   State of digital input pin, see canonical digital input.
* '(bit output) oshwdrv.<port>.din.<channel>.in-not' -
   Inverted state of digital input pin, see canonical digital input.
   
* '(bit input) oshwdrv.<port>.dout.<channel>.out' -
   Value to be written to digital output, see canonical digital output.
   
* '(float input) oshwdrv.<port>.stepenc.<channel>.step-velocity'  -
   Value which determines the step frequency. The value is multiplied
   by 'stepenc.<channel>.step-scale' , and the result is the frequency in
   steps per second. Negative values result in the frequency being based
   on the absolute value, and the direction pin is set to indicate negative.
* '(bit input) oshwdrv.<port>.stepenc.<channel>.step-enable' -
   Enables / disables the output of an frequency at the step pin.
* '(s32 output) oshwdrv.<port>.stepenc.<channel>.enc-count' -
   Encoder position, in raw encoder counts.
* '(s32 output) oshwdrv.<port>.stepenc.<channel>.enc-delta' -
   Change in counts since last read, in raw encoder count units.
* '(float output) oshwdrv.<port>.stepenc.<channel>.enc-position' -
   Encoder position, in user units.
* '(float output) 'oshwdrv.<port>.stepenc.<channel>.enc-velocity'  -
   Velocity scaled in user units per second. On oshwdrv this is derived from raw
   encoder counts per servo period, and hence is affected by encoder granularity.
* '(bit output) 'oshwdrv.<port>.stepenc.<channel>.enc-index'  -
   The raw index signal from the encoder.
* '(bit bidir) oshwdrv.<port>.stepenc.<channel>.enc-index-enable'  -
   Connect to joint.#.index-enable for home-to-index. This is a
   bidirectional HAL signal. Setting it to true causes the encoder
   hardware to reset the counter to zero on the next positive edge of the 
   encoder index pulse. The driver will detect this and set the signal back to false.
   Also connect this signal to pid.#.index-enable to prevent an spike at PID output
   in the moment the counter resets.

* '(bit input) oshwdrv.<port>.adcout.<channel-from>-<channel-to>.enable' -
   Enables the output (<channel-from> - <channel-to>) of the requested voltage.
* '(float output) 'oshwdrv.<port>.adcout.<channel>.value'  -
   Value of the requested output voltage at output <channel>.
   Range is from 0 to 10 VDC.

* '(float input) 'oshwdrv.<port>.adcin.<channel>.value'  -
   Value of the input voltage at input <channel>.
   Range is from 0 to 10 VDC.

* '(bit output) oshwdrv.<port>.watchdog.timeout' -
   Shows the status of the hardware communication. If high, there was a timeout.
   It should trigger the HAL estop function.
* '(bit input) oshwdrv.<port>.watchdog.estop' -
   Sends the estop status from HAL to the watchdog.
   To reset a timeout this pin needs to be changed from 1 to 0.
   
* '(bit input) oshwdrv.<port>.pwmout.<channel>.enable' -
   Enables the output of the requested PWM.
* '(float output) 'oshwdrv.<port>.pwmout.<channel>.pulswidth'  -
   Value of the requested pulse width ratio.
   Range is from 0.0 to 1.0.

* '(s32 output) oshwdrv.<port>.jog.<channel>.count' -
   Encoder position, in raw encoder counts.

* '(float output) oshwdrv.<port>.counter.<channel>.value' -
   Counter value scaled and offset subtracted.

* '(bit output) oshwdrv.<port>.mpgcom.<channel>.start' -
   MPG start button pressed.
* '(bit output) oshwdrv.<port>.mpgcom.<channel>.pause' -
   When HALUI is in program-run mode and MPG stop button is pressed first time.
* '(bit output) oshwdrv.<port>.mpgcom.<channel>.resume' -
   When HALUI is in program-paused mode and MPG start button is pressed.
* '(bit output) oshwdrv.<port>.mpgcom.<channel>.stop' -
   When HALUI is in program-paused mode and MPG stop button is pressed second time.
* '(bit input) oshwdrv.<port>.mpgcom.<channel>.program-running' -
   Used for start / stop buttons. Connect to halui.program.is-running.
* '(bit input) oshwdrv.<port>.mpgcom.<channel>.program-paused' -
   Used for start / stop buttons. Connect to halui.program.is-paused.
* '(bit output) oshwdrv.<port>.mpgcom.<channel>.null' -
   MPG null button pressed. To zero the selected axis.
* '(bit output) oshwdrv.<port>.mpgcom.<channel>.jog-enable-x' -
   X axis is selected at the MPG. Connect to axis.x.jog-enable.
* '(bit output) oshwdrv.<port>.mpgcom.<channel>.jog-enable-y' -
   Y axis is selected at the MPG. Connect to axis.y.jog-enable.
* '(bit output) oshwdrv.<port>.mpgcom.<channel>.jog-enable-z' -
   Z axis is selected at the MPG. Connect to axis.z.jog-enable.
* '(bit input) oshwdrv.<port>.mpgcom.<channel>.jog-teleop-mode' -
   Used for jog enable outputs. Connect to motion.teleop-mode.
* '(float output) oshwdrv.<port>.mpgcom.<channel>.jog-feed' -
   Output of the selected jog feedrate. Connect to axis.xyz.jog-scale.
   The values are set by parameter jog-feed-1 to -6.
* '(s32 output) oshwdrv.<port>.mpgcom.<channel>.jog-count' -
   Encoder position, in raw encoder counts. Connect to axis.xyz.jog-counts.
* '(float output) oshwdrv.<port>.mpgcom.<channel>.feed-f' -
   MPG feed poti output. Scaled and offset added.
* '(s32 output) oshwdrv.<port>.mpgcom.<channel>.feed-s32' -
   Same as above, only as signed 32 Bit.
* '(float output) oshwdrv.<port>.mpgcom.<channel>.speed-f' -
   MPG spindle RPM poti output. Scaled and offset added.
* '(s32 output) oshwdrv.<port>.mpgcom.<channel>.speed-s32' -
   Same as above, only as signed 32 Bit.

== Parameters

* '(bit) oshwdrv.<port>.dout.<channel>.invert' -
   Inverts a digital output, see canonical digital output.

* '(float) oshwdrv.<port>.stepenc.<channel>.step-scale' -
   Scaling for step generator. The step frequency in Hz is the
   absolute value of 'velocity' * 'scale'.
* '(float) oshwdrv.<port>.stepenc.<channel>.step-max-vel' -
   The maximum value for 'velocity'. Commands greater than 'step-max-vel'
   will be clamped. Also applies to negative values. (The absolute value is clamped.)
* '(u32) oshwdrv.<port>.stepenc.<channel>.step-pulse-width' -
   Sets width of step pulses, in units of 100ns. Applies to one or more 
   step generators. See FPGA firmware for details.
   Values between 100 ns and 25.5 us can be specified.
* '(u32) oshwdrv.<port>.stepenc.<channel>.step-setup-time' -
   Sets minimum time between direction change and step pulse, in
   units of 100ns. Applies to one or more consecutive step generators.
   See FPGA firmware for details. Values between 100 ns and 25.5 us can be specified.
* '(float) oshwdrv.<port>.stepenc.<channel>.step-frequency' -
   Actual step frequency in Hz (used mostly for troubleshooting.)
* '(float) oshwdrv.<port>.stepenc.<channel>.enc-scale' -
   The number of counts / user unit (to convert from counts to units).

* '(float) oshwdrv.<port>.adcout.<channel>.offset' -
   Offset is added to value. Then divided by scale.
* '(float) oshwdrv.<port>.adcout.<channel>.scale' -
   The value is divided by scale.

* '(float) oshwdrv.<port>.adcin.<channel>.offset' -
   Offset is subtracted from value.
* '(float) oshwdrv.<port>.adcin.<channel>.scale' -
   The value is multiplied with scale. Then offset is subtracted.

* '(float) oshwdrv.<port>.pwmout.<channel>.frequency' -
   The output frequency of the PWM. Range: 152 Hz to 300 kHz.
   Hint: The output frequency will be generated by dividing 10 MHz.
   So, if you want a high output frequency like 300 kHz the divider is (rounded) 33.
   The real output frequency is about 30.3 kHz. Due to the need of an minimum
   and maximum pulse width (the PWM will disapear if all time low or high),
   the resolution of the pulse width is only 3 to 32 clock ticks. Resulting in
   a minimum pulse width of about 9.09 % and a maximum of about 96.7 %.
   A higher output frequency results in a lower puls width resolution and vise versa.

* '(float) oshwdrv.<port>.counter.<channel>.offset' -
   Offset is subtracted from value.
* '(float) oshwdrv.<port>.counter.<channel>.scale' -
   The value is multiplied with scale. Then offset is subtracted.

* '(float) oshwdrv.<port>.mpgcom.<channel>.jog-feed-x' -
   Sets six jog feedrates, outputed by oshwdrv.<port>.mpgcom.<channel>.jog-feed.
* '(float) oshwdrv.<port>.mpgcom.<channel>.feed-offset' -
   Offset is added to the MPG feed value.
* '(float) oshwdrv.<port>.mpgcom.<channel>.feed-scale' -
   The MPG feed value is multiplied with scale. Then offset is added.
* '(float) oshwdrv.<port>.mpgcom.<channel>.speed-offset' -
   Offset is added to the MPG spindle RPM value.
* '(float) oshwdrv.<port>.mpgcom.<channel>.speed-scale' -
   The MPG spindle RPM value is multiplied with scale. Then offset is added.

== Functions

* '(funct) oshwdrv.<port>.read' -
   Reads all inputs from one port.
   These reads are organized into blocks of contiguous registers to be
   read in a block to minimize CPU overhead.
* '(funct) oshwdrv.<port>.write' -
   Writes all outputs to one port. 
   These writes are organized into blocks of contiguous registers to be
   written in a block to minimize CPU overhead.
